const express = require('express');
const path = require('path');
const fs = require('fs');
const { exec } = require('child_process');
const axios = require('axios');
const router = express.Router();

// === 🧠 Convert settings.json to admin-config.json ===
function mapSettingsToAdminConfig(settings) {
  const config = {
    intake: {
      requiredFields: {
        value: settings.requiredFields?.value || ["full_name", "email", "phone"]
      }
    },
    submission: {
      photoField: { value: "photo" },
      photoRequired: { enabled: settings.requirePhotoUpload?.enabled ?? true },
      generatePdfWithoutPhoto: { enabled: true },
      uploadToDrive: { enabled: settings.enableDriveUpload?.enabled ?? false },
      emailTarget: { value: "contact@yourcompany.com" }
    },
    pdf: {
      generatePDF: { enabled: settings.enablePdfGeneration?.enabled ?? true },
      header: { value: "Client Summary" },
      includeImages: { enabled: true },
      logoPlacement: { value: "top-left" },
      watermark: { value: "/branding/default/watermark.png" },
      footerText: { value: "Generated by Solomon AI" },
      filenamePrefix: { value: "Summary-" }
    },
    modules: {
      MonitorAI: {
        fallbackEnabled: { enabled: true }
      },
      Stripe: {
        enabled: settings.enableStripeCheckout?.enabled ?? false
      },
      OCR: {
        enabled: false
      },
      Analytics: {
        enabled: false
      }
    },
    branding: {
      brandingKey: { value: "default" },
      logoUrl: { value: "/branding/default/logo.png" },
      watermarkUrl: { value: "/branding/default/watermark.png" },
      primaryColor: { value: "#333333" }
    },
    ui: {
      typingIndicator: { enabled: true },
      exitMessage: { value: "Thanks for reaching out!" },
      photoPrompt: { value: "Upload a photo or skip to continue." },
      completeMessage: { value: "You're all set!" }
    },
    system: {
      sessionPrefix: { value: "GEN-" }
    }
  };

  return config;
}

const CONFIG_PATH = (company) => path.join(__dirname, company, 'settings.json');

// Load settings.json for selected company
router.get('/:company/settings.json', (req, res) => {
  const configPath = CONFIG_PATH(req.params.company);
  try {
    const config = fs.readFileSync(configPath, 'utf-8');
    res.json(JSON.parse(config));
  } catch (err) {
    res.status(500).json({ error: 'Failed to load settings.' });
  }
});

// Save updated settings.json
router.post('/:company/save-settings', (req, res) => {
  const configPath = CONFIG_PATH(req.params.company);
  try {
    fs.writeFileSync(configPath, JSON.stringify(req.body, null, 2));

  // === 🧠 Also write admin-config.json and .key for remote config ===
  const adminConfig = mapSettingsToAdminConfig(req.body);
  const configDir = path.join(__dirname, '..', 'configs');
  const clientConfigPath = path.join(configDir, `solomon-${req.params.company}.json`);
  const clientKeyPath = path.join(configDir, `solomon-${req.params.company}.key`);

  fs.mkdirSync(configDir, { recursive: true });
  fs.writeFileSync(clientConfigPath, JSON.stringify(adminConfig, null, 2));

  if (!fs.existsSync(clientKeyPath)) {
    const crypto = require('crypto');
    const key = crypto.randomBytes(24).toString('hex');
    fs.writeFileSync(clientKeyPath, key);
  }
    res.sendStatus(200);
  } catch (err) {
    res.status(500).json({ error: 'Failed to save settings.' });
  }
});

// Create new company + default settings.json + API key
router.post('/create-company', (req, res) => {
  const crypto = require('crypto');
  const company = req.body.company?.trim().toLowerCase().replace(/\s+/g, '-');
  if (!company) return res.status(400).json({ error: 'Invalid company name.' });

  const dir = path.join(__dirname, company);
  const configPath = CONFIG_PATH(company);
  const configDir = path.join(__dirname, '..', 'configs');
  const keyFile = path.join(configDir, `solomon-${company}.key`);

  if (fs.existsSync(configPath)) {
    return res.status(400).json({ error: 'Company already exists.' });
  }

  const defaultSettings = {
  "photoUpload": { "type": "toggle", "label": "Enable Photo Upload", "enabled": true },
  "summaryDownload": { "type": "toggle", "label": "Enable Summary Download", "enabled": true },
  "followUpEmail": { "type": "toggle", "label": "Send Follow-Up Email to Client", "enabled": false },
  "requirePhotoUpload": { "type": "toggle", "label": "Require Photo Upload Before Summary", "enabled": true },
  "enableDriveUpload": { "type": "toggle", "label": "Upload Files to Google Drive", "enabled": true },
  "enablePdfGeneration": { "type": "toggle", "label": "Generate PDF Summaries", "enabled": true },
  "enableStripeCheckout": { "type": "toggle", "label": "Require Stripe Payment for Intake", "enabled": false },
  "requiredFields": {
    "type": "list",
    "label": "Required Intake Fields",
    "value": [
      "full_name", "email", "phone",
      "garage_goals", "square_footage",
      "must_have_features", "budget",
      "start_date", "final_notes"
    ]
  },
  "allowSkipFields": { "type": "toggle", "label": "Allow Users to Skip Optional Fields", "enabled": true },
  "continueChatAfterIntake": { "type": "toggle", "label": "Continue Chat After Intake Completion", "enabled": true },

  "chatResponderPrompt": {
    "type": "textarea",
    "label": "Chat Responder Prompt",
    "value": "You are a helpful AI assistant that guides users through a garage intake process..."
  },
  "intakeExtractorPrompt": {
    "type": "textarea",
    "label": "Intake Extractor Prompt",
    "value": "Extract structured fields from the conversation: name, email, phone, etc..."
  },
  "doneCheckerPrompt": {
  "type": "textarea",
  "label": "Done Checker Prompt",
  "value": "You are a data completeness checker AI. Your task is to determine whether the extracted intake data includes meaningful, complete values for all required fields.\n\nRequired fields:\n{{required}}\n\nRules for completeness:\n- A field is incomplete if it is missing or blank.\n- Short, dismissive responses such as \"no\", \"none\", \"nope\", \"n/a\", or \"nothing else\" are considered valid and complete for all fields.\n- These checks are case-insensitive.\n- Any other non-empty value is also considered complete.\n\nIf all required fields are complete, respond only with:\n✅ All required fields are complete.\n\nIf any required fields are missing or incomplete, respond only with:\n❌ Missing or incomplete fields.\nMissing: [list of keys for the incomplete fields]\n\nDo not include explanations, greetings, or extra commentary.\n\nHere is the extracted intake data:\n{{fields}}"
  }
};

  try {
    fs.mkdirSync(dir, { recursive: true });
    fs.writeFileSync(configPath, JSON.stringify(defaultSettings, null, 2));

    fs.mkdirSync(configDir, { recursive: true });
    const apiKey = crypto.randomUUID(); // you could also use randomBytes for longer keys
    fs.writeFileSync(keyFile, apiKey);

    res.status(200).json({ success: true, apiKey });
  } catch (err) {
    console.error("❌ Failed to create company:", err.message);
    res.status(500).json({ error: 'Failed to create company folder or config.' });
  }
});

// Optional: Trigger provisioning of a Solomon instance
router.post('/provision-company', (req, res) => {
  const rawCompany = req.body.company?.trim().toLowerCase();
  if (!rawCompany) return res.status(400).json({ error: 'Missing company name.' });

  const company = rawCompany.replace(/[^a-zA-Z0-9_-]/g, '-');
  const deploymentDir = path.join(__dirname, '..', 'provisioned', `solomon-${company}`);
  const envPath = path.join(deploymentDir, '.env');
  const envContent = [
    'USE_REMOTE_CONFIG=true',
    `DEPLOYMENT_ID=solomon-${company}`,
    `CONFIG_URL=https://portal.veralux.ai/config/solomon-${company}`,
    `CONFIG_API_KEY=${process.env.DEFAULT_CONFIG_API_KEY || 'replace-me'}`
  ].join('\n');

  fs.mkdirSync(deploymentDir, { recursive: true });
  fs.writeFileSync(envPath, envContent);


  const command = `node provision-client.cjs --name ${company}`;
  exec(command, (error, stdout, stderr) => {
    console.log("STDOUT:", stdout);
    console.log("STDERR:", stderr);

    if (error) {
      console.error("Exec error:", error.message);
      return res.status(500).json({ error: error.message });
    }

  // ✅ Read deployment info after exec completes
    const deploymentsPath = path.join(__dirname, '..', 'deployments.json');
    let deployments = {};
    if (fs.existsSync(deploymentsPath)) {
      deployments = JSON.parse(fs.readFileSync(deploymentsPath, 'utf8'));
    }

    const key = `solomon-${company}`;
    const deployed = deployments[key] || {};

    res.json({
      success: true,
      company,
      output: stdout.trim(),
      renderUrl: deployed.renderUrl || null,
      githubRepo: deployed.githubRepo || null,
      serviceId: deployed.serviceId || null
    });
  });
});

// 🧠 Generate AI Prompt (chatResponderPrompt or intakeExtractorPrompt)
const { generatePrompts } = require('./ai/promptGenerator');

router.post('/generate-prompt', async (req, res) => {
  const { purpose, business, tone } = req.body;
  const company = req.session?.company || req.body.company;

  if (!purpose || !business) {
    return res.status(400).json({ success: false, error: "Missing purpose or business." });
  }

  try {
    const prompts = await generatePrompts(purpose, business, tone);

    const settings = {
  chatResponderPrompt: {
    type: "textarea",
    label: "Chat Responder Prompt",
    value: prompts.chatResponderPrompt
  },
  intakeExtractorPrompt: {
    type: "textarea",
    label: "Intake Extractor Prompt",
    value: prompts.intakeExtractorPrompt
  },
  requiredFields: {
    type: "list",
    label: "Required Intake Fields",
    value: prompts.requiredFields
  },
  sourceMap: {}
};

// 👇 Populate sourceMap from requiredFields
prompts.requiredFields.forEach(field => {
  settings.sourceMap[field] = "AI";
});


    // Save new config to file
    const filePath = path.join(__dirname, '..', company, 'settings.json');

    const dir = path.dirname(filePath);

// ✅ Ensure the directory exists
if (!fs.existsSync(dir)) {
  fs.mkdirSync(dir, { recursive: true });
}

    fs.writeFileSync(filePath, JSON.stringify(settings, null, 2));


    res.json({ success: true, prompts });
  } catch (err) {
    console.error("❌ Failed to generate prompts:", err);
    res.status(500).json({ success: false, error: "Prompt generation failed" });
  }
});



async function deploySolomonInstance(company) {
  const renderAPI = 'https://api.render.com/v1/services';
  const apiKey = process.env.RENDER_API_KEY;
  const serviceId = process.env.RENDER_SOLOMON_SERVICE_ID; // Add this to your .env

  const response = await axios.post(
    'https://api.render.com/v1/services/srv-cvva0v0dl3ps739foekg/deploys',
    {},
    {
       headers: {
         Authorization: `Bearer ${apiKey}`,
         'Content-Type': 'application/json',
       }
     }
  );


  return response.data;
}

router.post('/deploy-company', async (req, res) => {
  const { company } = req.body;
  try {
    const result = await deploySolomonInstance(company);
    res.status(200).json({ success: true, deployment: result });
  } catch (err) {
    console.error("❌ Render deploy error:", err.message);
    res.status(500).json({ success: false, error: err.message });
  }
});

const multer = require('multer');
const getColors = require('get-image-colors');
const sharp = require('sharp');

const upload = multer({ dest: 'uploads/' });

router.post('/extract-logo-colors', upload.single('logo'), async (req, res) => {
  const fs = require('fs');
  const path = require('path');

  try {
    const originalPath = req.file.path;
    const convertedPath = `${originalPath}.png`;

    // Convert uploaded image to PNG with Sharp
    await sharp(originalPath).png().toFile(convertedPath);

    // Extract colors from clean PNG
    const colors = await getColors(convertedPath);
    const hexColors = colors.map(color => color.hex());

    // Optional: Clean up temp files
    try { fs.unlinkSync(originalPath); } catch (e) {}
    try { fs.unlinkSync(convertedPath); } catch (e) {}

    // ✅ Send success response
    res.json({ success: true, colors: hexColors });
  } catch (err) {
    console.error('Color extraction error:', err);
    res.status(500).json({ error: 'Failed to extract colors' });
  }
});

// POST /admin/proxy-render-deploy
router.post('/proxy-render-deploy', async (req, res) => {
  try {
    const RENDER_API_KEY = process.env.RENDER_API_KEY;
    if (!RENDER_API_KEY) {
      return res.status(500).json({ error: "Missing RENDER_API_KEY in server .env" });
    }

    const payload = req.body;
    console.log("📦 Proxying Render Deploy with Payload:");
    console.log(JSON.stringify(payload, null, 2));

    const renderRes = await fetch("https://api.render.com/v1/services", {
      method: "POST",
      headers: {
        "Authorization": `Bearer ${RENDER_API_KEY}`,
        "Content-Type": "application/json"
      },
      body: JSON.stringify(payload)
    });

    const rawText = await renderRes.text(); // Get raw response body
    console.log("📥 Raw Response Text from Render:");
    console.log(rawText);

    let result;
    try {
      result = JSON.parse(rawText);
    } catch (e) {
      result = { message: "Non-JSON response from Render", raw: rawText };
    }

    if (!renderRes.ok) {
      console.error("❌ Render Proxy Deploy Failed:");
      console.error("🔢 Status Code:", renderRes.status);
      console.error("🧾 Parsed Error Message:", result.message);
      return res.status(500).json({
        error: result.message || "Unknown Render error",
        status: renderRes.status,
        raw: result
      });
    }

    console.log(`✅ Render Proxy Deploy Success: ${result.service.url}`);
    return res.json({
      success: true,
      renderUrl: result.service.url,
      serviceId: result.service.id
    });

  } catch (err) {
    console.error("❌ Render Proxy Error:", err);
    return res.status(500).json({ error: err.message });
  }
});


module.exports = router;



router.get('/list-deployments', (req, res) => {
  const configsDir = path.join(__dirname, '..', 'configs');
  try {
    const files = fs.readdirSync(configsDir).filter(f => f.endsWith('.json'));

    const deployments = files.map(file => {
      const name = file.replace('.json', '');
      const configPath = path.join(configsDir, file);
      const keyPath = path.join(configsDir, `${name}.key`);
      const hasKey = fs.existsSync(keyPath);
      const stats = fs.statSync(configPath);
      const lastUpdated = stats.mtime.toISOString().split('T')[0];
      return {
        name,
        hasKey,
        lastUpdated
      };
    });

    res.json({ success: true, deployments });
  } catch (err) {
    console.error("Failed to list deployments:", err.message);
    res.status(500).json({ success: false, error: 'Failed to read deployments' });
  }
});

const session = require('express-session');

router.use(session({
  secret: 'veralux-secret-key',
  resave: false,
  saveUninitialized: true
}));

function requireLogin(req, res, next) {
  if (req.session.loggedIn) return next();
  res.redirect('/admin/login.html');
}

router.get('/logout', (req, res) => {
  req.session.destroy(() => res.redirect('/admin/login.html'));
});

router.post('/login', (req, res) => {
  const password = req.body.password;
  if (password === process.env.ADMIN_PASSWORD) {
    req.session.loggedIn = true;
    res.redirect('/admin');
  } else {
    res.status(401).send('Unauthorized');
  }
});
