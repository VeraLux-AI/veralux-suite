const express = require('express');
const path = require('path');
const fs = require('fs');
const { exec } = require('child_process');
const axios = require('axios');
const router = express.Router();

// === 🧠 Convert settings.json to admin-config.json ===
function mapSettingsToAdminConfig(settings) {
  const config = {
    intake: {
      requiredFields: {
        value: settings.requiredFields?.value || ["full_name", "email", "phone"]
      }
    },
    submission: {
      photoField: { value: "photo" },
      photoRequired: { enabled: settings.requirePhotoUpload?.enabled ?? true },
      generatePdfWithoutPhoto: { enabled: true },
      uploadToDrive: { enabled: settings.enableDriveUpload?.enabled ?? false },
      emailTarget: { value: "contact@yourcompany.com" }
    },
    pdf: {
      generatePDF: { enabled: settings.enablePdfGeneration?.enabled ?? true },
      header: { value: "Client Summary" },
      includeImages: { enabled: true },
      logoPlacement: { value: "top-left" },
      watermark: { value: "/branding/default/watermark.png" },
      footerText: { value: "Generated by Solomon AI" },
      filenamePrefix: { value: "Summary-" }
    },
    modules: {
      MonitorAI: {
        fallbackEnabled: { enabled: true }
      },
      Stripe: {
        enabled: settings.enableStripeCheckout?.enabled ?? false
      },
      OCR: {
        enabled: false
      },
      Analytics: {
        enabled: false
      }
    },
    branding: {
      brandingKey: { value: "default" },
      logoUrl: { value: "/branding/default/logo.png" },
      watermarkUrl: { value: "/branding/default/watermark.png" },
      primaryColor: { value: "#333333" }
    },
    ui: {
      typingIndicator: { enabled: true },
      exitMessage: { value: "Thanks for reaching out!" },
      photoPrompt: { value: "Upload a photo or skip to continue." },
      completeMessage: { value: "You're all set!" }
    },
    system: {
      sessionPrefix: { value: "GEN-" }
    }
  };

  return config;
}

const CONFIG_PATH = (company) => path.join(__dirname, company, 'settings.json');

// Load settings.json for selected company
router.get('/:company/settings.json', (req, res) => {
  const configPath = CONFIG_PATH(req.params.company);
  try {
    const config = fs.readFileSync(configPath, 'utf-8');
    res.json(JSON.parse(config));
  } catch (err) {
    res.status(500).json({ error: 'Failed to load settings.' });
  }
});

// Save updated settings.json
router.post('/:company/save-settings', (req, res) => {
  const configPath = CONFIG_PATH(req.params.company);
  try {
    fs.writeFileSync(configPath, JSON.stringify(req.body, null, 2));

  // === 🧠 Also write admin-config.json and .key for remote config ===
  const adminConfig = mapSettingsToAdminConfig(req.body);
  const configDir = path.join(__dirname, '..', 'configs');
  const clientConfigPath = path.join(configDir, `solomon-${req.params.company}.json`);
  const clientKeyPath = path.join(configDir, `solomon-${req.params.company}.key`);
  
  fs.mkdirSync(configDir, { recursive: true });
  fs.writeFileSync(clientConfigPath, JSON.stringify(adminConfig, null, 2));

  if (!fs.existsSync(clientKeyPath)) {
    const crypto = require('crypto');
    const key = crypto.randomBytes(24).toString('hex');
    fs.writeFileSync(clientKeyPath, key);
  }
    res.sendStatus(200);
  } catch (err) {
    res.status(500).json({ error: 'Failed to save settings.' });
  }
});

// Create new company + default settings.json
router.post('/create-company', (req, res) => {
  const company = req.body.company?.trim().toLowerCase().replace(/\s+/g, '-');
  if (!company) return res.status(400).json({ error: 'Invalid company name.' });

  const dir = path.join(__dirname, company);
  const configPath = CONFIG_PATH(company);

  if (fs.existsSync(configPath)) {
    return res.status(400).json({ error: 'Company already exists.' });
  }

  const defaultSettings = {
    "photoUpload": { "type": "toggle", "label": "Enable Photo Upload", "enabled": true },
    "summaryDownload": { "type": "toggle", "label": "Enable Summary Download", "enabled": true },
    "followUpEmail": { "type": "toggle", "label": "Send Follow-Up Email to Client", "enabled": false },
    "requirePhotoUpload": { "type": "toggle", "label": "Require Photo Upload Before Summary", "enabled": true },
    "enableDriveUpload": { "type": "toggle", "label": "Upload Files to Google Drive", "enabled": true },
    "enablePdfGeneration": { "type": "toggle", "label": "Generate PDF Summaries", "enabled": true },
    "enableStripeCheckout": { "type": "toggle", "label": "Require Stripe Payment for Intake", "enabled": false },
    "requiredFields": {
      "type": "list",
      "label": "Required Intake Fields",
      "value": [
        "full_name", "email", "phone",
        "garage_goals", "square_footage",
        "must_have_features", "budget",
        "start_date", "final_notes"
      ]
    },
    "allowSkipFields": { "type": "toggle", "label": "Allow Users to Skip Optional Fields", "enabled": true },
    "continueChatAfterIntake": { "type": "toggle", "label": "Continue Chat After Intake Completion", "enabled": true },
    "chatResponderPrompt": {
      "type": "textarea",
      "label": "Chat Responder Prompt",
      "value": "You are a helpful AI assistant that guides users through a garage intake process..."
    },
    "intakeExtractorPrompt": {
      "type": "textarea",
      "label": "Intake Extractor Prompt",
      "value": "Extract structured fields from the conversation: name, email, phone, etc..."
    }
  };

  try {
    fs.mkdirSync(dir, { recursive: true });
    fs.writeFileSync(configPath, JSON.stringify(defaultSettings, null, 2));
    res.status(200).json({ success: true });
  } catch (err) {
    console.error("❌ Failed to create company:", err.message);
    res.status(500).json({ error: 'Failed to create company folder or config.' });
  }
});

// Optional: Trigger provisioning of a Solomon instance
router.post('/provision-company', (req, res) => {
  const rawCompany = req.body.company?.trim().toLowerCase();
  if (!rawCompany) return res.status(400).json({ error: 'Missing company name.' });

  // ✅ Sanitize to remove unsafe characters
  const company = rawCompany.replace(/[^a-zA-Z0-9_-]/g, '-');

  // === 🧪 Inject .env into the new provisioned folder ===
  const deploymentDir = path.join(__dirname, '..', 'provisioned', `solomon-${company}`);
  const envPath = path.join(deploymentDir, '.env');
  const configKeyPath = path.join(__dirname, '..', 'configs', `solomon-${company}.key`);

  const envContent = [
    'USE_REMOTE_CONFIG=true',
    `DEPLOYMENT_ID=solomon-${company}`,
    `CONFIG_URL=https://portal.veralux.ai/config/solomon-${company}`,
    `CONFIG_API_KEY=${fs.readFileSync(configKeyPath, 'utf-8').trim()}`
  ].join('\n');

  fs.mkdirSync(deploymentDir, { recursive: true });
  fs.writeFileSync(envPath, envContent);
  const command = `node provision-client.js --name ${company}`;
  exec(command, (error, stdout, stderr) => {
    if (error) return res.status(500).json({ error: error.message });
    if (stderr) console.warn(stderr);
    res.json({ success: true, output: stdout.trim() });
  });
});

// 🧠 Generate AI Prompt (chatResponderPrompt or intakeExtractorPrompt)
const { generatePrompts } = require('./ai/promptGenerator');

router.post('/generate-prompt', async (req, res) => {
  const { purpose, business, tone } = req.body;
  const company = req.session?.company || req.body.company;

  if (!purpose || !business) {
    return res.status(400).json({ success: false, error: "Missing purpose or business." });
  }

  try {
    const prompts = await generatePrompts(purpose, business, tone);
   
    const settings = {
  chatResponderPrompt: {
    type: "textarea",
    label: "Chat Responder Prompt",
    value: prompts.chatResponderPrompt
  },
  intakeExtractorPrompt: {
    type: "textarea",
    label: "Intake Extractor Prompt",
    value: prompts.intakeExtractorPrompt
  },
  requiredFields: {
    type: "list",
    label: "Required Intake Fields",
    value: prompts.requiredFields
  },
  sourceMap: {}
};

// 👇 Populate sourceMap from requiredFields
prompts.requiredFields.forEach(field => {
  settings.sourceMap[field] = "AI";
});


    // Save new config to file
    const filePath = path.join(__dirname, '..', company, 'settings.json');

    const dir = path.dirname(filePath);

// ✅ Ensure the directory exists
if (!fs.existsSync(dir)) {
  fs.mkdirSync(dir, { recursive: true });
}
    
    fs.writeFileSync(filePath, JSON.stringify(settings, null, 2));


    res.json({ success: true, prompts });
  } catch (err) {
    console.error("❌ Failed to generate prompts:", err);
    res.status(500).json({ success: false, error: "Prompt generation failed" });
  }
});



async function deploySolomonInstance(company) {
  const renderAPI = 'https://api.render.com/v1/services';
  const apiKey = process.env.RENDER_API_KEY;
  const serviceId = process.env.RENDER_SOLOMON_SERVICE_ID; // Add this to your .env

  const response = await axios.post(
    'https://api.render.com/v1/services/srv-cvva0v0dl3ps739foekg/deploys',
    {},
    {
       headers: {
         Authorization: `Bearer ${apiKey}`,
         'Content-Type': 'application/json',
       }
     }
  );


  return response.data;
}

router.post('/deploy-company', async (req, res) => {
  const { company } = req.body;
  try {
    const result = await deploySolomonInstance(company);
    res.status(200).json({ success: true, deployment: result });
  } catch (err) {
    console.error("❌ Render deploy error:", err.message);
    res.status(500).json({ success: false, error: err.message });
  }
});

const multer = require('multer');
const getColors = require('get-image-colors');
const sharp = require('sharp');

const upload = multer({ dest: 'uploads/' });

router.post('/extract-logo-colors', upload.single('logo'), async (req, res) => {
  const fs = require('fs');
  const path = require('path');

  try {
    const originalPath = req.file.path;
    const convertedPath = `${originalPath}.png`;

    // Convert uploaded image to PNG with Sharp
    await sharp(originalPath).png().toFile(convertedPath);

    // Extract colors from clean PNG
    const colors = await getColors(convertedPath);
    const hexColors = colors.map(color => color.hex());

    // Optional: Clean up temp files
    try { fs.unlinkSync(originalPath); } catch (e) {}
    try { fs.unlinkSync(convertedPath); } catch (e) {}

    // ✅ Send success response
    res.json({ success: true, colors: hexColors });
  } catch (err) {
    console.error('Color extraction error:', err);
    res.status(500).json({ error: 'Failed to extract colors' });
  }
});


module.exports = router;



router.get('/list-deployments', (req, res) => {
  const configsDir = path.join(__dirname, '..', 'configs');
  try {
    const files = fs.readdirSync(configsDir).filter(f => f.endsWith('.json'));

    const deployments = files.map(file => {
      const name = file.replace('.json', '');
      const configPath = path.join(configsDir, file);
      const keyPath = path.join(configsDir, `${name}.key`);
      const hasKey = fs.existsSync(keyPath);
      const stats = fs.statSync(configPath);
      const lastUpdated = stats.mtime.toISOString().split('T')[0];
      return {
        name,
        hasKey,
        lastUpdated
      };
    });

    res.json({ success: true, deployments });
  } catch (err) {
    console.error("Failed to list deployments:", err.message);
    res.status(500).json({ success: false, error: 'Failed to read deployments' });
  }
});

const session = require('express-session');

router.use(session({
  secret: 'veralux-secret-key',
  resave: false,
  saveUninitialized: true
}));

function requireLogin(req, res, next) {
  if (req.session.loggedIn) return next();
  res.redirect('/admin/login.html');
}

router.get('/logout', (req, res) => {
  req.session.destroy(() => res.redirect('/admin/login.html'));
});

router.post('/login', (req, res) => {
  const password = req.body.password;
  if (password === process.env.ADMIN_PASSWORD) {
    req.session.loggedIn = true;
    res.redirect('/admin');
  } else {
    res.status(401).send('Unauthorized');
  }
});
